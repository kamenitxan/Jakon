package cz.kamenitxan.jakon.core.model.Dao

import java.io.{BufferedReader, InputStreamReader}
import java.sql._
import java.util.stream.Collectors

import com.zaxxer.hikari.{HikariConfig, HikariDataSource}
import cz.kamenitxan.jakon.core.configuration.{DatabaseType, Settings}
import cz.kamenitxan.jakon.core.model._
import cz.kamenitxan.jakon.core.model.converters.AbstractConverter
import cz.kamenitxan.jakon.utils.Utils
import cz.kamenitxan.jakon.webui.entity.JakonField
import javax.persistence.ManyToOne
import org.slf4j.{Logger, LoggerFactory}

import scala.collection.mutable

/**
  * Created by Kamenitxan (kamenitxan@me.com) on 20.12.15.
  */
object DBHelper {
	private val logger: Logger = LoggerFactory.getLogger(this.getClass)

	val objects: mutable.ArrayBuffer[Class[_ <: JakonObject]] = mutable.ArrayBuffer[Class[_ <: JakonObject]]()


	addDao(classOf[AclRule])
	addDao(classOf[JakonUser])

	val config = new HikariConfig
	config.setJdbcUrl(Settings.getDatabaseConnPath)
	config.setUsername(Settings.getDatabaseUser)
	config.setPassword(Settings.getDatabasePass)
	config.addDataSourceProperty("cachePrepStmts", "true")
	config.addDataSourceProperty("prepStmtCacheSize", "250")
	config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048")
	if (Settings.getDatabaseType == DatabaseType.SQLITE) {
		config.addDataSourceProperty("PRAGMA foreign_keys", "ON")
		config.addDataSourceProperty("PRAGMA journal_mode", "wal")
	}
	val ds = new HikariDataSource(config)
	ds.setLeakDetectionThreshold(60 * 1000)


	def addDao[T <: JakonObject](jobject: Class[T]) {
		objects += jobject
	}

	def createTables(): Unit = {
		val dbobj = mutable.ArrayBuffer[Class[_ <: JakonObject]]()
		objects.copyToBuffer(dbobj)
		dbobj.+=:(classOf[JakonObject])
		val conn = getConnection
		for (o <- dbobj) {
			val className = o.getSimpleName
			val check = "SELECT 1 FROM " + className + " LIMIT 1"

			val stmt = conn.createStatement()
			var found = false
			try {
				stmt.executeQuery(check)
				found = true
			} catch {
				case _: SQLException =>
			}
			stmt.close()

			if (found) {
				logger.debug(className + " found in DB")
			} else {
				logger.info(className + " not found in DB")
				val resource = this.getClass.getResourceAsStream(s"/sql/$className.sql")
				if (resource != null) {
					var sql = new BufferedReader(new InputStreamReader(resource)).lines().collect(Collectors.joining("\n"))
					if (Settings.getDatabaseType == DatabaseType.SQLITE) {
						sql = sql.replaceAll("AUTO_INCREMENT", "")
					}
					val stmt = conn.createStatement()
					stmt.execute(sql)
					stmt.close()
				} else {
					logger.error(s"Table definition for $className not found")
				}
			}

		}
		conn.close()
	}


	def getDaoClasses: mutable.ArrayBuffer[Class[_ <: JakonObject]] = objects

	/**
	  * @param id      searched JakonObject id
	  * @param refresh if true, object is queried from DB. not cache
	  * @return JakonObject or null
	  */
	@deprecated def getObjectById(id: Integer, refresh: Boolean): JakonObject = {
		throw new UnsupportedOperationException("Not implemented")
	}

	/**
	  * @param id searched JakonObject id
	  * @return JakonObject or null
	  */
	def getObjectById(id: Integer): JakonObject = {
		getObjectById(id, refresh = false)
	}

	def getConnection: Connection = {
		//TODO: single conn for request
		val conn = ds.getConnection
		//logger.info("Got DB connection - " + conn)
		conn
	}

	@Deprecated
	def getPreparedStatement(sql: String): PreparedStatement = {
		getConnection.prepareStatement(sql)
	}

	@Deprecated
	def getPreparedStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = {
		getConnection.prepareStatement(sql, autoGeneratedKeys)
	}

	def execute(stmt: PreparedStatement): ResultSet = {
		stmt.executeQuery()
	}

	def execute(stmt: Statement, sql: String): ResultSet = {
		stmt.executeQuery(sql)
	}

	private val S = classOf[String]
	private val B = classOf[Boolean]
	private val I = classOf[Int]
	private val D = classOf[Double]
	private val MAP = classOf[Map[Any, Any]]

	def createJakonObject(rs: ResultSet, cls: Class[_ <: JakonObject]): QueryResult = {
		val rsmd = rs.getMetaData
		val obj = cls.newInstance()
		var foreignIds = Map[String, ForeignKeyInfo]()
		val columnCount = rsmd.getColumnCount

		Iterator.from(1).takeWhile(i => i <= columnCount).foreach(i => {
			val columnName = rsmd.getColumnName(i)
			val fieldName = if (columnName.endsWith("_id")) {
				columnName.substring(0, columnName.length - 3)
			} else {
				columnName
			}
			val fieldRef = Utils.getFieldsUpTo(cls, classOf[Object]).find(f => f.getName.equalsIgnoreCase(fieldName))
			if (fieldRef.nonEmpty) {
				val field = fieldRef.get
				field.setAccessible(true)
				field.getType match {
					case S => field.set(obj, rs.getString(columnName))
					case B => field.set(obj, rs.getBoolean(columnName))
					case I => field.set(obj, rs.getInt(columnName))
					case D => field.set(obj, rs.getDouble(columnName))
					case x if x.isEnum =>
						val m = x.getMethod("valueOf", classOf[String])
						val enumValue = m.invoke(null, rs.getString(columnName))
						field.set(obj, enumValue)
					case _ =>
						val manyToOne = field.getAnnotation(classOf[ManyToOne])
						lazy val jakonField = field.getAnnotation(classOf[JakonField])
						if (manyToOne != null) {
							val fv = rs.getInt(columnName)
							if (fv > 0) {
								foreignIds += (columnName -> new ForeignKeyInfo(rs.getInt(columnName), columnName, field))
							}
						} else if (jakonField != null) {
							val converter = jakonField.converter()
							if (converter.getName != classOf[AbstractConverter[_]].getName) {
								field.set(obj, converter.newInstance().convertToEntityAttribute(rs.getString(columnName)))
							}

						} else {
							logger.warn("Uknown data type on " + cls.getSimpleName + s".$fieldName")
						}
				}

			}
		})
		new QueryResult(obj,foreignIds)
	}

	def select(stmt: PreparedStatement, cls: Class[_ <: JakonObject]): List[QueryResult] = {
		val rs = execute(stmt)
		val res = Iterator.from(0).takeWhile(_ => rs.next()).map(_ => {
			createJakonObject(rs, cls)
		}).toList
		stmt.close()
		res
	}

	def select(stmt: Statement, sql: String, cls: Class[_ <: JakonObject]): List[QueryResult] = {
		val rs = execute(stmt, sql)
		val res = Iterator.from(0).takeWhile(_ => rs.next()).map(_ => {
			createJakonObject(rs, cls)
		}).toList
		stmt.close()
		res
	}

	def selectSingle(stmt: PreparedStatement, cls: Class[_ <: JakonObject]): QueryResult = {
		val rs = execute(stmt)
		var res: QueryResult = null
		if (rs.next()) {
			res = createJakonObject(rs, cls)
		} else {
			res = new QueryResult(null, null)
		}
		stmt.close()
		res
	}

	def selectSingle(stmt: Statement, sql: String, cls: Class[_ <: JakonObject]): QueryResult = {
		val rs = execute(stmt, sql)
		val res = createJakonObject(rs, cls)
		stmt.close()
		res
	}

	def selectSingleDeep(stmt: PreparedStatement, cls: Class[_ <: JakonObject]): JakonObject = {
		val res = selectSingle(stmt, cls)
		if (res.foreignIds != null && res.foreignIds.nonEmpty) {
			res.foreignIds.values.foreach(fki => {
				val cls = fki.field.getType
				val sql = "SELECT * FROM " + cls.getSimpleName + " WHERE id = ?"
				val stmt = getPreparedStatement(sql)
				stmt.setInt(1, fki.id)
				val r = selectSingleDeep(stmt, cls.asInstanceOf[Class[JakonObject]])
				stmt.close()
				fki.field.set(res.entity, r)
			})
		}
		res.entity
	}

	def selectDeep(stmt: Statement, sql: String, cls: Class[_ <: JakonObject])(implicit conn: Connection): List[JakonObject] = {
		val res = select(stmt, sql, cls)
		fetchForeignObjects(res)
		res.map(r => r.entity)
	}

	def selectDeep(stmt: PreparedStatement, cls: Class[_ <: JakonObject])(implicit conn: Connection): List[JakonObject] = {
		val res: List[QueryResult] = select(stmt, cls)
		fetchForeignObjects(res)
		res.map(r => r.entity)
	}

	def fetchForeignObjects(res: List[QueryResult])(implicit conn: Connection): List[QueryResult] = {
		res.foreach(r => {
			if (r.foreignIds.nonEmpty) {
				r.foreignIds.foreach(fki => {
					val field = fki._2.field
					val objectClass = field.getType.asInstanceOf[Class[JakonObject]]
					val stmt = conn.prepareStatement(s"SELECT * FROM ${objectClass.getSimpleName} WHERE id = ?")
					stmt.setInt(1, fki._2.id)
					val res = selectSingle(stmt, objectClass)
					field.set(r.entity, res.entity)
				})
			}
		})
		res
	}


}